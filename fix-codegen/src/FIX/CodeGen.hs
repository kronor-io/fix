{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

module FIX.CodeGen (runFixCodeGen) where

import Control.Monad
import qualified Data.Text as T
import FIX.CodeGen.OptParse
import FIX.CodeGen.Spec
import Language.Haskell.TH as TH
import Path
import Path.IO
import System.Exit
import System.Process
import qualified Text.XML as XML

runFixCodeGen :: IO ()
runFixCodeGen = do
  Settings {..} <- getSettings
  doc <- XML.readFile XML.def (fromAbsFile settingsSpecFile)
  case parseSpec doc of
    Nothing -> die "Failed to parse specfication."
    Just spec -> do
      let fieldSpecs = specFields spec
      writeFieldsFile settingsOutputDir fieldSpecs
      writeFieldsGenFile settingsOutputDir fieldSpecs
      writeFieldsSpecFile settingsOutputDir fieldSpecs

      let messageSpecs = specMessages spec
      writeMessagesFile settingsOutputDir messageSpecs

disclaimer :: String
disclaimer =
  unlines
    [ "-- | This module has been GENERATED by fix-codegen.",
      "-- Any manual edits will be undone the next time fix-codegen is run."
    ]

fieldSpecConstructorName :: FieldSpec -> Name
fieldSpecConstructorName = mkName . T.unpack . fieldName

writeFieldsFile :: Path Abs Dir -> [FieldSpec] -> IO ()
writeFieldsFile outputDir fieldSpecs = do
  fieldsFile <- resolveFile outputDir "fix-spec/src/FIX/Fields.hs"
  sections <- forM fieldSpecs $ \f@FieldSpec {..} -> do
    let constructorName = fieldSpecConstructorName f
    let selectorName = mkName $ "un" <> T.unpack fieldName
    let typ = case fieldType of
          FieldTypeBoolean -> ConT (mkName "Bool")
          _ -> ConT (mkName "ByteString")
    pure
      [ "-- " <> show f,
        TH.pprint
          [ NewtypeD
              []
              constructorName
              []
              Nothing
              (RecC constructorName [(selectorName, Bang NoSourceUnpackedness NoSourceStrictness, typ)])
              [ DerivClause
                  (Just StockStrategy)
                  [ ConT (mkName "Show"),
                    ConT (mkName "Eq"),
                    ConT (mkName "Generic")
                  ]
              ],
            InstanceD
              Nothing
              []
              (AppT (ConT (mkName "Validity")) (ConT constructorName))
              [],
            InstanceD
              Nothing
              []
              (AppT (ConT (mkName "IsField")) (ConT constructorName))
              [ FunD
                  (mkName "fieldTag")
                  [ Clause
                      [VarP (mkName "Proxy")]
                      (NormalB (LitE (IntegerL (toInteger fieldNumber))))
                      []
                  ],
                FunD
                  (mkName "fieldIsData")
                  [ Clause
                      [VarP (mkName "Proxy")]
                      ( NormalB
                          ( ConE
                              (mkName $ show $ fieldTypeIsData fieldType)
                          )
                      )
                      []
                  ],
                FunD
                  (mkName "fieldToValue")
                  [ Clause
                      []
                      ( NormalB
                          ( InfixE
                              (Just (VarE (mkName "toValue")))
                              (VarE (mkName "."))
                              (Just (VarE selectorName))
                          )
                      )
                      []
                  ],
                FunD
                  (mkName "fieldFromValue")
                  [ Clause
                      []
                      ( NormalB
                          ( InfixE
                              (Just (VarE (mkName "fromValue")))
                              (VarE (mkName ">=>"))
                              ( Just
                                  ( InfixE
                                      (Just (VarE (mkName "prettyValidate")))
                                      (VarE (mkName "."))
                                      (Just (VarE constructorName))
                                  )
                              )
                          )
                      )
                      []
                  ]
              ]
          ]
      ]

  ensureDir (parent fieldsFile)
  writeFile (fromAbsFile fieldsFile) $
    unlines $
      concat $
        [ "{-# LANGUAGE DerivingStrategies #-}",
          "{-# LANGUAGE DeriveGeneric #-}",
          "",
          disclaimer,
          "module FIX.Fields where",
          "",
          "import Data.ByteString (ByteString)",
          "import Data.Proxy",
          "import Data.Validity",
          "import FIX.Core (IsFieldType(..), IsField(..))",
          "import GHC.Generics (Generic)",
          "import Control.Monad"
        ]
          : sections
  callProcess "ormolu" ["-i", "-c", fromAbsFile fieldsFile]

writeFieldsGenFile :: Path Abs Dir -> [FieldSpec] -> IO ()
writeFieldsGenFile outputDir fieldSpecs = do
  fieldsGenFile <- resolveFile outputDir "fix-spec-gen/src/FIX/Fields/Gen.hs"
  sections <- forM fieldSpecs $ \f -> do
    let constructorName = fieldSpecConstructorName f
    pure
      [ TH.pprint
          [ InstanceD Nothing [] (AppT (ConT (mkName "GenValid")) (ConT constructorName)) []
          ]
      ]
  ensureDir (parent fieldsGenFile)
  writeFile (fromAbsFile fieldsGenFile) $
    unlines $
      concat $
        [ "{-# OPTIONS_GHC -Wno-orphans #-}",
          "",
          disclaimer,
          "module FIX.Fields.Gen where",
          "",
          "import Data.GenValidity.ByteString ()",
          "import Data.GenValidity",
          "import FIX.Fields"
        ]
          : sections
  callProcess "ormolu" ["-i", "-c", fromAbsFile fieldsGenFile]

writeFieldsSpecFile :: Path Abs Dir -> [FieldSpec] -> IO ()
writeFieldsSpecFile outputDir fieldSpecs = do
  fieldsSpecFile <- resolveFile outputDir "fix-spec-gen/test/FIX/FieldsSpec.hs"
  statements <- forM fieldSpecs $ \f -> do
    let constructorName = fieldSpecConstructorName f
    pure $ NoBindS (AppTypeE (VarE (mkName "fieldSpec")) (ConT constructorName))

  ensureDir (parent fieldsSpecFile)
  writeFile (fromAbsFile fieldsSpecFile) $
    unlines
      [ "{-# OPTIONS_GHC -Wno-orphans #-}",
        "{-# LANGUAGE TypeApplications #-}",
        "",
        disclaimer,
        "module FIX.FieldsSpec where",
        "",
        "import Test.Syd",
        "import FIX.Core.TestUtils",
        "import FIX.Fields",
        "import FIX.Fields.Gen ()",
        TH.pprint
          [ SigD (mkName "spec") (ConT (mkName "Spec")),
            FunD (mkName "spec") [Clause [] (NormalB (DoE Nothing statements)) []]
          ]
      ]

  callProcess "ormolu" ["-i", "-c", fromAbsFile fieldsSpecFile]

messageSpecConstructorName :: MessageSpec -> Name
messageSpecConstructorName = mkName . T.unpack . messageName

writeMessagesFile :: Path Abs Dir -> [MessageSpec] -> IO ()
writeMessagesFile outputDir messageSpecs = do
  messagesFile <- resolveFile outputDir "fix-spec/src/FIX/Messages.hs"
  messageSections <- forM messageSpecs $ \f -> do
    let constructorName = messageSpecConstructorName f
    let section =
          [ "-- " <> show f,
            TH.pprint
              [ DataD
                  []
                  constructorName
                  []
                  Nothing
                  []
                  [ DerivClause
                      (Just StockStrategy)
                      [ ConT (mkName "Show"),
                        ConT (mkName "Eq"),
                        ConT (mkName "Generic")
                      ]
                  ],
                InstanceD
                  Nothing
                  []
                  (AppT (ConT (mkName "Validity")) (ConT constructorName))
                  []
              ]
          ]
    mapM_ putStrLn section
    pure section

  ensureDir (parent messagesFile)
  writeFile (fromAbsFile messagesFile) $
    unlines $
      concat $
        [ "{-# LANGUAGE DerivingStrategies #-}",
          "{-# LANGUAGE DeriveGeneric #-}",
          "",
          disclaimer,
          "module FIX.Messages where",
          "",
          "import Data.ByteString (ByteString)",
          "import Data.Proxy",
          "import Data.Validity",
          "import FIX.Core (IsMessage(..))",
          "import GHC.Generics (Generic)",
          "import Control.Monad",
          ""
        ]
          : messageSections
  callProcess "ormolu" ["-i", "-c", fromAbsFile messagesFile]
