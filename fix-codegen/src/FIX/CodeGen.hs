{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

module FIX.CodeGen (runFixCodeGen) where

import Control.Monad
import qualified Data.Text as T
import FIX.CodeGen.OptParse
import FIX.CodeGen.Spec
import Language.Haskell.TH as TH
import Path
import Path.IO
import System.Exit
import System.Process
import qualified Text.XML as XML

runFixCodeGen :: IO ()
runFixCodeGen = do
  Settings {..} <- getSettings
  doc <- XML.readFile XML.def (fromAbsFile settingsSpecFile)
  case parseSpec doc of
    Nothing -> die "Failed to parse specfication."
    Just spec -> do
      let fieldSpecs = specFields spec
      writeFieldsFile settingsOutputDir fieldSpecs
      writeFieldsGenFile settingsOutputDir fieldSpecs
      writeFieldsSpecFile settingsOutputDir fieldSpecs

      let messageSpecs = specMessages spec
      writeMessagesFile settingsOutputDir messageSpecs

disclaimer :: String
disclaimer =
  unlines
    [ "-- | This module has been GENERATED by fix-codegen.",
      "-- Any manual edits will be undone the next time fix-codegen is run."
    ]

fieldSpecConstructorName :: FieldSpec -> Name
fieldSpecConstructorName = mkName . T.unpack . fieldName

fieldValueSpecConstructorName :: FieldSpec -> FieldValueSpec -> Name
fieldValueSpecConstructorName FieldSpec {..} FieldValueSpec {..} =
  mkName $
    concat
      [ T.unpack fieldName,
        "_",
        T.unpack fieldValueDescription -- TODO fix the casing
      ]

writeFieldsFile :: Path Abs Dir -> [FieldSpec] -> IO ()
writeFieldsFile outputDir fieldSpecs = do
  fieldsFile <- resolveFile outputDir "fix-spec/src/FIX/Fields.hs"
  sections <- forM fieldSpecs $ \f@FieldSpec {..} -> do
    let constructorName = fieldSpecConstructorName f
    let selectorName = mkName $ "un" <> T.unpack fieldName
    let typ = case fieldType of
          FieldTypeBoolean -> ConT (mkName "Bool")
          _ -> ConT (mkName "ByteString")
    pure
      [ "-- " <> show f,
        TH.pprint
          [ if null fieldValues
              then
                NewtypeD
                  []
                  constructorName
                  []
                  Nothing
                  (RecC constructorName [(selectorName, Bang NoSourceUnpackedness NoSourceStrictness, typ)])
                  [ DerivClause
                      (Just StockStrategy)
                      [ ConT (mkName "Show"),
                        ConT (mkName "Eq"),
                        ConT (mkName "Generic")
                      ]
                  ]
              else
                DataD
                  []
                  constructorName
                  []
                  Nothing
                  (map (\fvs -> NormalC (fieldValueSpecConstructorName f fvs) []) fieldValues)
                  [ DerivClause
                      (Just StockStrategy)
                      [ ConT (mkName "Show"),
                        ConT (mkName "Eq"),
                        ConT (mkName "Generic")
                      ]
                  ],
            InstanceD
              Nothing
              []
              (AppT (ConT (mkName "Validity")) (ConT constructorName))
              [],
            InstanceD
              Nothing
              []
              (AppT (ConT (mkName "IsField")) (ConT constructorName))
              [ FunD
                  (mkName "fieldTag")
                  [ Clause
                      [VarP (mkName "Proxy")]
                      (NormalB (LitE (IntegerL (toInteger fieldNumber))))
                      []
                  ],
                FunD
                  (mkName "fieldIsData")
                  [ Clause
                      [VarP (mkName "Proxy")]
                      ( NormalB
                          ( ConE
                              (mkName $ show $ fieldTypeIsData fieldType)
                          )
                      )
                      []
                  ],
                FunD
                  (mkName "fieldToValue")
                  [ Clause
                      []
                      ( NormalB
                          ( if null fieldValues
                              then
                                InfixE
                                  (Just (VarE (mkName "toValue")))
                                  (VarE (mkName "."))
                                  (Just (VarE selectorName))
                              else
                                LamCaseE $
                                  map
                                    ( \fvs ->
                                        Match
                                          ( ConP
                                              (fieldValueSpecConstructorName f fvs)
                                              []
                                              []
                                          )
                                          (NormalB (LitE (StringL (T.unpack (fieldValueEnum fvs)))))
                                          []
                                    )
                                    fieldValues
                          )
                      )
                      []
                  ],
                FunD
                  (mkName "fieldFromValue")
                  [ Clause
                      []
                      ( NormalB
                          ( if null fieldValues
                              then
                                InfixE
                                  (Just (VarE (mkName "fromValue")))
                                  (VarE (mkName ">=>"))
                                  ( Just
                                      ( InfixE
                                          (Just (VarE (mkName "prettyValidate")))
                                          (VarE (mkName "."))
                                          (Just (VarE constructorName))
                                      )
                                  )
                              else
                                LamCaseE $
                                  concat
                                    [ map
                                        ( \fvs ->
                                            Match
                                              (LitP (StringL (T.unpack (fieldValueEnum fvs))))
                                              ( NormalB
                                                  ( AppE
                                                      (ConE (mkName "Right"))
                                                      (ConE (fieldValueSpecConstructorName f fvs))
                                                  )
                                              )
                                              []
                                        )
                                        fieldValues,
                                      [ let vn = mkName "v"
                                         in Match
                                              (VarP vn)
                                              ( NormalB
                                                  ( AppE
                                                      (ConE (mkName "Left"))
                                                      ( InfixE
                                                          (Just (LitE (StringL $ "Unknown " <> T.unpack fieldName <> ": ")))
                                                          (VarE (mkName "<>"))
                                                          (Just (AppE (VarE (mkName "show")) (VarE vn)))
                                                      )
                                                  )
                                              )
                                              []
                                      ]
                                    ]
                          )
                      )
                      []
                  ]
              ]
          ]
      ]

  ensureDir (parent fieldsFile)
  writeFile (fromAbsFile fieldsFile) $
    unlines $
      concat $
        [ "{-# LANGUAGE DerivingStrategies #-}",
          "{-# LANGUAGE DeriveGeneric #-}",
          "{-# LANGUAGE LambdaCase #-}",
          "{-# LANGUAGE OverloadedStrings #-}",
          "",
          disclaimer,
          "module FIX.Fields where",
          "",
          "import Data.ByteString (ByteString)",
          "import Data.Proxy",
          "import Data.Validity",
          "import FIX.Core (IsFieldType(..), IsField(..))",
          "import GHC.Generics (Generic)",
          "import Control.Monad"
        ]
          : sections
  callProcess "ormolu" ["-i", "-c", fromAbsFile fieldsFile]

writeFieldsGenFile :: Path Abs Dir -> [FieldSpec] -> IO ()
writeFieldsGenFile outputDir fieldSpecs = do
  fieldsGenFile <- resolveFile outputDir "fix-spec-gen/src/FIX/Fields/Gen.hs"
  sections <- forM fieldSpecs $ \f -> do
    let constructorName = fieldSpecConstructorName f
    pure
      [ TH.pprint
          [ InstanceD Nothing [] (AppT (ConT (mkName "GenValid")) (ConT constructorName)) []
          ]
      ]
  ensureDir (parent fieldsGenFile)
  writeFile (fromAbsFile fieldsGenFile) $
    unlines $
      concat $
        [ "{-# OPTIONS_GHC -Wno-orphans #-}",
          "",
          disclaimer,
          "module FIX.Fields.Gen where",
          "",
          "import Data.GenValidity.ByteString ()",
          "import Data.GenValidity",
          "import FIX.Fields"
        ]
          : sections
  callProcess "ormolu" ["-i", "-c", fromAbsFile fieldsGenFile]

writeFieldsSpecFile :: Path Abs Dir -> [FieldSpec] -> IO ()
writeFieldsSpecFile outputDir fieldSpecs = do
  fieldsSpecFile <- resolveFile outputDir "fix-spec-gen/test/FIX/FieldsSpec.hs"
  statements <- forM fieldSpecs $ \f -> do
    let constructorName = fieldSpecConstructorName f
    pure $ NoBindS (AppTypeE (VarE (mkName "fieldSpec")) (ConT constructorName))

  ensureDir (parent fieldsSpecFile)
  writeFile (fromAbsFile fieldsSpecFile) $
    unlines
      [ "{-# OPTIONS_GHC -Wno-orphans #-}",
        "{-# LANGUAGE TypeApplications #-}",
        "",
        disclaimer,
        "module FIX.FieldsSpec where",
        "",
        "import Test.Syd",
        "import FIX.Core.TestUtils",
        "import FIX.Fields",
        "import FIX.Fields.Gen ()",
        TH.pprint
          [ SigD (mkName "spec") (ConT (mkName "Spec")),
            FunD (mkName "spec") [Clause [] (NormalB (DoE Nothing statements)) []]
          ]
      ]

  callProcess "ormolu" ["-i", "-c", fromAbsFile fieldsSpecFile]

messageSpecConstructorName :: MessageSpec -> Name
messageSpecConstructorName = mkName . T.unpack . messageName

writeMessagesFile :: Path Abs Dir -> [MessageSpec] -> IO ()
writeMessagesFile outputDir messageSpecs = do
  messagesFile <- resolveFile outputDir "fix-spec/src/FIX/Messages.hs"
  messageSections <- forM messageSpecs $ \f -> do
    let constructorName = messageSpecConstructorName f
    pure
      [ "-- " <> show f,
        TH.pprint
          [ DataD
              []
              constructorName
              []
              Nothing
              []
              [ DerivClause
                  (Just StockStrategy)
                  [ -- ConT (mkName "Show"),
                    -- ConT (mkName "Eq"),
                    ConT (mkName "Generic")
                  ]
              ],
            InstanceD
              Nothing
              []
              (AppT (ConT (mkName "Validity")) (ConT constructorName))
              []
          ]
      ]

  ensureDir (parent messagesFile)
  writeFile (fromAbsFile messagesFile) $
    unlines $
      concat $
        [ "{-# LANGUAGE DerivingStrategies #-}",
          "{-# LANGUAGE DeriveGeneric #-}",
          "",
          disclaimer,
          "module FIX.Messages where",
          "",
          "import Data.Validity",
          "import GHC.Generics (Generic)",
          ""
        ]
          : messageSections
  callProcess "ormolu" ["-i", "-c", fromAbsFile messagesFile]
