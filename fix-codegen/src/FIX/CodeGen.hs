{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

module FIX.CodeGen (runFixCodeGen) where

import Control.Monad
import qualified Data.Text as T
import FIX.CodeGen.OptParse
import FIX.CodeGen.Spec
import Language.Haskell.TH as TH
import Path
import Path.IO
import System.Exit
import System.Process
import qualified Text.XML as XML

runFixCodeGen :: IO ()
runFixCodeGen = do
  Settings {..} <- getSettings
  doc <- XML.readFile XML.def (fromAbsFile settingsSpecFile)
  case parseSpec doc of
    Nothing -> die "Failed to parse specfication."
    Just spec -> do
      let fieldSpecs = specFields spec
      writeFieldsFile settingsOutputDir fieldSpecs
      writeFieldsGenFile settingsOutputDir fieldSpecs

disclaimer :: String
disclaimer =
  unlines
    [ "-- | This module has been GENERATED by fix-codegen.",
      "-- Any manual edits will be undone the next time fix-codegen is run."
    ]

writeFieldsGenFile :: Path Abs Dir -> [FieldSpec] -> IO ()
writeFieldsGenFile outputDir fieldSpecs = do
  fieldsGenFile <- resolveFile outputDir "fix-spec-gen/src/FIX/Fields/Gen.hs"
  sections <- forM fieldSpecs $ \FieldSpec {..} -> do
    let constructorName = mkName $ T.unpack fieldName
    pure
      [ TH.pprint
          [ InstanceD Nothing [] (AppT (ConT (mkName "GenValid")) (ConT constructorName)) []
          ]
      ]
  ensureDir (parent fieldsGenFile)
  writeFile (fromAbsFile fieldsGenFile) $
    unlines $
      concat $
        [ "{-# OPTIONS_GHC -Wno-orphans #-}",
          "",
          disclaimer,
          "module FIX.Fields.Gen where",
          "",
          "import Data.GenValidity.ByteString ()",
          "import Data.GenValidity",
          "import FIX.Fields"
        ]
          : sections
  callProcess "ormolu" ["-i", "-c", fromAbsFile fieldsGenFile]

writeFieldsFile :: Path Abs Dir -> [FieldSpec] -> IO ()
writeFieldsFile outputDir fieldSpecs = do
  fieldsFile <- resolveFile outputDir "fix-spec/src/FIX/Fields.hs"
  sections <- forM fieldSpecs $ \f@FieldSpec {..} -> do
    let constructorName = mkName $ T.unpack fieldName
    let selectorName = mkName $ "un" <> T.unpack fieldName
    let typ = case fieldType of
          FieldTypeBoolean -> ConT (mkName "Bool")
          _ -> ConT (mkName "ByteString")
    pure
      [ "-- " <> show f,
        TH.pprint
          [ NewtypeD
              []
              constructorName
              []
              Nothing
              (RecC constructorName [(selectorName, Bang NoSourceUnpackedness NoSourceStrictness, typ)])
              [ DerivClause
                  (Just StockStrategy)
                  [ ConT (mkName "Show"),
                    ConT (mkName "Eq"),
                    ConT (mkName "Generic")
                  ]
              ],
            InstanceD
              Nothing
              []
              (AppT (ConT (mkName "Validity")) (ConT constructorName))
              [],
            InstanceD
              Nothing
              []
              (AppT (ConT (mkName "IsField")) (ConT constructorName))
              [ FunD
                  (mkName "fieldTag")
                  [ Clause
                      [VarP (mkName "Proxy")]
                      (NormalB (LitE (IntegerL (toInteger fieldNumber))))
                      []
                  ],
                FunD
                  (mkName "fieldIsData")
                  [ Clause
                      [VarP (mkName "Proxy")]
                      ( NormalB
                          ( ConE
                              (mkName $ show $ fieldTypeIsData fieldType)
                          )
                      )
                      []
                  ],
                FunD
                  (mkName "fieldToValue")
                  [ Clause
                      []
                      ( NormalB
                          ( InfixE
                              (Just (VarE (mkName "toValue")))
                              (VarE (mkName "."))
                              (Just (VarE selectorName))
                          )
                      )
                      []
                  ],
                FunD
                  (mkName "fieldFromValue")
                  [ Clause
                      []
                      ( NormalB
                          ( InfixE
                              (Just (VarE (mkName "fromValue")))
                              (VarE (mkName ">=>"))
                              ( Just
                                  ( InfixE
                                      (Just (VarE (mkName "prettyValidate")))
                                      (VarE (mkName "."))
                                      (Just (VarE constructorName))
                                  )
                              )
                          )
                      )
                      []
                  ]
              ]
          ]
      ]

  ensureDir (parent fieldsFile)
  writeFile (fromAbsFile fieldsFile) $
    unlines $
      concat $
        [ "{-# LANGUAGE DerivingStrategies #-}",
          "{-# LANGUAGE DeriveGeneric #-}",
          "",
          disclaimer,
          "module FIX.Fields where",
          "",
          "import Data.ByteString (ByteString)",
          "import Data.Proxy",
          "import Data.Validity",
          "import FIX.Core (IsFieldType(..), IsField(..))",
          "import GHC.Generics (Generic)",
          "import Control.Monad"
        ]
          : sections
  callProcess "ormolu" ["-i", "-c", fromAbsFile fieldsFile]
