{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

module FIX.CodeGen (runFixCodeGen) where

import Control.Monad
import qualified Data.Text as T
import FIX.CodeGen.OptParse
import FIX.CodeGen.Spec
import Language.Haskell.TH as TH
import Path
import Path.IO
import System.Exit
import qualified Text.XML as XML

runFixCodeGen :: IO ()
runFixCodeGen = do
  Settings {..} <- getSettings
  doc <- XML.readFile XML.def (fromAbsFile settingsSpecFile)
  case parseSpec doc of
    Nothing -> die "Failed to parse specfication."
    Just spec -> do
      fieldsFile <- resolveFile settingsOutputDir "src/FIX/Fields.hs"
      sections <- forM (specFields spec) $ \f@FieldSpec {..} -> do
        let constructorName = mkName $ T.unpack fieldName
        let selectorName = mkName $ "un" <> T.unpack fieldName
        let typ = case fieldType of
              FieldTypeBoolean -> ConT (mkName "Bool")
              _ -> ConT (mkName "ByteString")
        pure
          [ "-- " <> show f,
            TH.pprint
              [ NewtypeD
                  []
                  constructorName
                  []
                  Nothing
                  (RecC constructorName [(selectorName, Bang NoSourceUnpackedness NoSourceStrictness, typ)])
                  [ DerivClause
                      (Just StockStrategy)
                      [ ConT (mkName "Show"),
                        ConT (mkName "Eq"),
                        ConT (mkName "Generic")
                      ]
                  ],
                InstanceD
                  Nothing
                  []
                  (AppT (ConT (mkName "Validity")) (ConT constructorName))
                  [],
                InstanceD
                  Nothing
                  []
                  (AppT (ConT (mkName "IsField")) (ConT constructorName))
                  [ FunD
                      (mkName "fieldTag")
                      [ Clause
                          [VarP (mkName "Proxy")]
                          (NormalB (LitE (IntegerL (toInteger fieldNumber))))
                          []
                      ],
                    FunD
                      (mkName "fieldIsData")
                      [ Clause
                          [VarP (mkName "Proxy")]
                          ( NormalB
                              ( ConE
                                  (mkName $ show $ fieldTypeIsData fieldType)
                              )
                          )
                          []
                      ],
                    FunD
                      (mkName "fieldToValue")
                      [ Clause
                          []
                          ( NormalB
                              ( InfixE
                                  (Just (VarE (mkName "toValue")))
                                  (VarE (mkName "."))
                                  (Just (VarE selectorName))
                              )
                          )
                          []
                      ],
                    FunD
                      (mkName "fieldFromValue")
                      [ Clause
                          []
                          ( NormalB
                              ( InfixE
                                  (Just (VarE (mkName "fromValue")))
                                  (VarE (mkName ">=>"))
                                  ( Just
                                      ( InfixE
                                          (Just (VarE (mkName "prettyValidate")))
                                          (VarE (mkName "."))
                                          (Just (VarE constructorName))
                                      )
                                  )
                              )
                          )
                          []
                      ]
                  ]
              ]
          ]

      ensureDir (parent fieldsFile)
      writeFile (fromAbsFile fieldsFile) $
        unlines $
          concat $
            [ "{-# LANGUAGE DerivingStrategies #-}",
              "{-# LANGUAGE DeriveGeneric #-}",
              "",
              "-- | This module has been GENERATED by fix-codegen.",
              "-- Any manual edits will be undone the next time fix-codegen is run.",
              "module FIX.Fields where",
              "",
              "import Data.ByteString (ByteString)",
              "import Data.Proxy",
              "import Data.Validity",
              "import FIX.Core",
              "import GHC.Generics (Generic)"
            ]
              : sections
