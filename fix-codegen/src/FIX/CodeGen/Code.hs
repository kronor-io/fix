{-# LANGUAGE LambdaCase #-}

module FIX.CodeGen.Code where

import Data.Char as Char
import Data.Map (Map)
import qualified Data.Map as M
import Path
import Path.IO
import Paths_fix_codegen (getDataDir)
import System.Process
import UnliftIO

newtype CodeGen = CodeGen {unCodeGen :: Map FilePath GenContents}

data GenContents
  = GenHaskell !String
  | GenHaskellDataFile
  | GenDataFile

instance Semigroup CodeGen where
  (<>) (CodeGen m1) (CodeGen m2) = CodeGen (M.union m1 m2)

instance Monoid CodeGen where
  mempty = CodeGen M.empty
  mappend = (<>)

genHaskellFile :: FilePath -> String -> CodeGen
genHaskellFile fp contents = CodeGen $ M.singleton fp $ GenHaskell contents

genHaskellDataFile :: FilePath -> CodeGen
genHaskellDataFile fp = CodeGen $ M.singleton fp GenHaskellDataFile

genDataFile :: FilePath -> CodeGen
genDataFile fp = CodeGen $ M.singleton fp GenDataFile

-- We run all the IO here so that we can maximally use concurrency and only pass in the ouputDir once.
runCodeGen :: Path Abs Dir -> CodeGen -> IO ()
runCodeGen outputDir (CodeGen m) =
  forConcurrently_ (M.toList m) $ \(fp, gc) -> case gc of
    GenHaskell contents -> do
      af <- resolveFile outputDir fp
      writeHaskellCode af contents
    GenHaskellDataFile -> copyHaskellDataFile outputDir fp
    GenDataFile -> do
      dataDir <- getDataDir >>= resolveDir' >>= (`resolveDir` "data")
      from <- resolveFile dataDir fp
      to <- resolveFile outputDir fp
      ensureDir (parent to)
      copyFile from to

copyHaskellDataFile :: Path Abs Dir -> FilePath -> IO ()
copyHaskellDataFile outputDir filePath = do
  dataDir <- getDataDir >>= resolveDir' >>= (`resolveDir` "data")
  fromFile <- resolveFile dataDir filePath
  contents <- readFile (fromAbsFile fromFile)
  messagesClassFile <- resolveFile outputDir filePath
  writeHaskellCode messagesClassFile contents

writeHaskellCode :: Path Abs File -> String -> IO ()
writeHaskellCode f source = do
  ensureDir (parent f)
  putStrLn $ unwords ["Writing", fromAbsFile f]
  writeFile (fromAbsFile f) $ disclaimer <> source
  runOrmoluOn f

disclaimer :: String
disclaimer =
  unlines
    [ "-- | This module has been GENERATED by fix-codegen.",
      "-- Any manual edits will be undone the next time fix-codegen is run."
    ]

runOrmoluOn :: Path Abs File -> IO ()
runOrmoluOn f = callProcess "ormolu" ["-i", "-c", fromAbsFile f]

lowerHead :: String -> String
lowerHead = \case
  [] -> []
  (c : cs) -> Char.toLower c : cs
