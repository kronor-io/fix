{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

-- | This module has been GENERATED by fix-codegen.
-- Any manual edits will be undone the next time fix-codegen is run.
module FIX.Groups.PartyIDsGroupElem where

import Data.Proxy
import Data.Validity
import FIX.Components.Class
import FIX.Components.PtysSubGrp
import FIX.Fields.MsgType
import FIX.Fields.NoPartyIDs
import FIX.Fields.PartyID
import FIX.Fields.PartyIDSource
import FIX.Fields.PartyRole
import FIX.Groups.Class
import GHC.Generics (Generic)

-- | GroupSpec
--   { groupName = "NoPartyIDs"
--   , groupPieces =
--       [ MessagePieceField "PartyID" True
--       , MessagePieceField "PartyIDSource" False
--       , MessagePieceField "PartyRole" False
--       , MessagePieceComponent "PtysSubGrp" True
--       ]
--   }
data PartyIDsGroupElem = PartyIDsGroupElem
  { partyIDsGroupElemPartyID :: !PartyID,
    partyIDsGroupElemPartyIDSource :: !(Maybe PartyIDSource),
    partyIDsGroupElemPartyRole :: !(Maybe PartyRole),
    partyIDsGroupElemPtysSubGrp :: !PtysSubGrp
  }
  deriving stock (Show, Eq, Generic)

instance Validity PartyIDsGroupElem

instance IsComponent PartyIDsGroupElem where
  toComponentFields ((PartyIDsGroupElem {..})) =
    mconcat
      [ requiredFieldB partyIDsGroupElemPartyID,
        optionalFieldB partyIDsGroupElemPartyIDSource,
        optionalFieldB partyIDsGroupElemPartyRole,
        requiredComponentB partyIDsGroupElemPtysSubGrp
      ]
  fromComponentFields = do
    partyIDsGroupElemPartyID <- requiredFieldP
    partyIDsGroupElemPartyIDSource <- optionalFieldP
    partyIDsGroupElemPartyRole <- optionalFieldP
    partyIDsGroupElemPtysSubGrp <- requiredComponentP
    pure (PartyIDsGroupElem {..})

instance IsGroupElement PartyIDsGroupElem where
  type GroupNumField PartyIDsGroupElem = NoPartyIDs
  mkGroupNum Proxy = NoPartyIDs
  countGroupNum Proxy = unNoPartyIDs
