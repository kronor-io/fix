{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

-- | This module has been GENERATED by fix-codegen.
-- Any manual edits will be undone the next time fix-codegen is run.
module FIX.Groups.UnderlyingsGroupElem where

import Data.List.NonEmpty (NonEmpty)
import Data.Proxy
import Data.Validity
import FIX.Components.Class
import FIX.Fields.MsgType
import FIX.Fields.NoUnderlyings
import FIX.Fields.UnderlyingMaturityDate
import FIX.Fields.UnderlyingSecurityDesc
import FIX.Fields.UnderlyingSecurityID
import FIX.Fields.UnderlyingSymbol
import FIX.Groups.Class
import GHC.Generics (Generic)

-- | GroupSpec
--   { groupName = "NoUnderlyings"
--   , groupNumberField = "NoUnderlyings"
--   , groupPieces =
--       [ MessagePieceField "UnderlyingSymbol" True
--       , MessagePieceField "UnderlyingSecurityID" True
--       , MessagePieceField "UnderlyingMaturityDate" True
--       , MessagePieceField "UnderlyingSecurityDesc" True
--       ]
--   }
data UnderlyingsGroupElem = UnderlyingsGroupElem
  { underlyingsGroupElemUnderlyingSymbol :: !UnderlyingSymbol,
    underlyingsGroupElemUnderlyingSecurityID :: !UnderlyingSecurityID,
    underlyingsGroupElemUnderlyingMaturityDate :: !UnderlyingMaturityDate,
    underlyingsGroupElemUnderlyingSecurityDesc :: !UnderlyingSecurityDesc
  }
  deriving stock (Show, Eq, Generic)

instance Validity UnderlyingsGroupElem

instance IsComponent UnderlyingsGroupElem where
  toComponentFields ((UnderlyingsGroupElem {..})) =
    mconcat
      [ requiredFieldB underlyingsGroupElemUnderlyingSymbol,
        requiredFieldB underlyingsGroupElemUnderlyingSecurityID,
        requiredFieldB underlyingsGroupElemUnderlyingMaturityDate,
        requiredFieldB underlyingsGroupElemUnderlyingSecurityDesc
      ]
  fromComponentFields = do
    underlyingsGroupElemUnderlyingSymbol <- requiredFieldP
    underlyingsGroupElemUnderlyingSecurityID <- requiredFieldP
    underlyingsGroupElemUnderlyingMaturityDate <- requiredFieldP
    underlyingsGroupElemUnderlyingSecurityDesc <- requiredFieldP
    pure (UnderlyingsGroupElem {..})

instance IsGroupElement UnderlyingsGroupElem where
  type GroupNumField UnderlyingsGroupElem = NoUnderlyings
  mkGroupNum Proxy = NoUnderlyings
  countGroupNum Proxy = unNoUnderlyings

makeUnderlyingsGroupElem :: UnderlyingSymbol -> (UnderlyingSecurityID -> (UnderlyingMaturityDate -> (UnderlyingSecurityDesc -> UnderlyingsGroupElem)))
makeUnderlyingsGroupElem underlyingsGroupElemUnderlyingSymbol underlyingsGroupElemUnderlyingSecurityID underlyingsGroupElemUnderlyingMaturityDate underlyingsGroupElemUnderlyingSecurityDesc =
  let
   in (UnderlyingsGroupElem {..})
