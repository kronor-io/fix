{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

-- | This module has been GENERATED by fix-codegen.
-- Any manual edits will be undone the next time fix-codegen is run.
module FIX.Groups.NewOrderMultilegLegsLegAllocsGroupElem where

import Data.List.NonEmpty (NonEmpty)
import Data.Proxy
import Data.Validity
import FIX.Components.Class
import FIX.Fields.LegAllocAccount
import FIX.Fields.LegAllocAcctIDSource
import FIX.Fields.LegAllocQty
import FIX.Fields.LegIndividualAllocID
import FIX.Fields.LegSettlCurrency
import FIX.Fields.MsgType
import FIX.Fields.NoLegAllocs
import FIX.Groups.Class
import FIX.Groups.NewOrderMultilegLegsLegAllocsNestedParties2GroupElem
import GHC.Generics (Generic)

-- | GroupSpec
--   { groupName = "NewOrderMultilegLegsLegAllocs"
--   , groupNumberField = "NoLegAllocs"
--   , groupPieces =
--       [ MessagePieceField "LegAllocAccount" True
--       , MessagePieceField "LegIndividualAllocID" False
--       , MessagePieceGroup
--           GroupSpec
--             { groupName = "NewOrderMultilegLegsLegAllocsNestedParties2"
--             , groupNumberField = "NoNested2PartyIDs"
--             , groupPieces =
--                 [ MessagePieceField "Nested2PartyID" True
--                 , MessagePieceField "Nested2PartyIDSource" False
--                 , MessagePieceField "Nested2PartyRole" False
--                 , MessagePieceGroup
--                     GroupSpec
--                       { groupName =
--                           "NewOrderMultilegLegsLegAllocsNestedParties2Nested2PartySubIDs"
--                       , groupNumberField = "NoNested2PartySubIDs"
--                       , groupPieces =
--                           [ MessagePieceField "Nested2PartySubID" True
--                           , MessagePieceField "Nested2PartySubIDType" False
--                           ]
--                       }
--                     False
--                 ]
--             }
--           False
--       , MessagePieceField "LegAllocQty" False
--       , MessagePieceField "LegAllocAcctIDSource" False
--       , MessagePieceField "LegSettlCurrency" False
--       ]
--   }
data NewOrderMultilegLegsLegAllocsGroupElem = NewOrderMultilegLegsLegAllocsGroupElem
  { newOrderMultilegLegsLegAllocsGroupElemLegAllocAccount :: !LegAllocAccount,
    newOrderMultilegLegsLegAllocsGroupElemLegIndividualAllocID :: !(Maybe LegIndividualAllocID),
    newOrderMultilegLegsLegAllocsGroupElemNewOrderMultilegLegsLegAllocsNestedParties2Group :: ![NewOrderMultilegLegsLegAllocsNestedParties2GroupElem],
    newOrderMultilegLegsLegAllocsGroupElemLegAllocQty :: !(Maybe LegAllocQty),
    newOrderMultilegLegsLegAllocsGroupElemLegAllocAcctIDSource :: !(Maybe LegAllocAcctIDSource),
    newOrderMultilegLegsLegAllocsGroupElemLegSettlCurrency :: !(Maybe LegSettlCurrency)
  }
  deriving stock (Show, Eq, Generic)

instance Validity NewOrderMultilegLegsLegAllocsGroupElem

instance IsComponent NewOrderMultilegLegsLegAllocsGroupElem where
  toComponentFields ((NewOrderMultilegLegsLegAllocsGroupElem {..})) =
    mconcat
      [ requiredFieldB newOrderMultilegLegsLegAllocsGroupElemLegAllocAccount,
        optionalFieldB newOrderMultilegLegsLegAllocsGroupElemLegIndividualAllocID,
        optionalGroupB newOrderMultilegLegsLegAllocsGroupElemNewOrderMultilegLegsLegAllocsNestedParties2Group,
        optionalFieldB newOrderMultilegLegsLegAllocsGroupElemLegAllocQty,
        optionalFieldB newOrderMultilegLegsLegAllocsGroupElemLegAllocAcctIDSource,
        optionalFieldB newOrderMultilegLegsLegAllocsGroupElemLegSettlCurrency
      ]
  fromComponentFields = do
    newOrderMultilegLegsLegAllocsGroupElemLegAllocAccount <- requiredFieldP
    newOrderMultilegLegsLegAllocsGroupElemLegIndividualAllocID <- optionalFieldP
    newOrderMultilegLegsLegAllocsGroupElemNewOrderMultilegLegsLegAllocsNestedParties2Group <- optionalGroupP
    newOrderMultilegLegsLegAllocsGroupElemLegAllocQty <- optionalFieldP
    newOrderMultilegLegsLegAllocsGroupElemLegAllocAcctIDSource <- optionalFieldP
    newOrderMultilegLegsLegAllocsGroupElemLegSettlCurrency <- optionalFieldP
    pure (NewOrderMultilegLegsLegAllocsGroupElem {..})

instance IsGroupElement NewOrderMultilegLegsLegAllocsGroupElem where
  type GroupNumField NewOrderMultilegLegsLegAllocsGroupElem = NoLegAllocs
  mkGroupNum Proxy = NoLegAllocs
  countGroupNum Proxy = unNoLegAllocs

makeNewOrderMultilegLegsLegAllocsGroupElem :: LegAllocAccount -> NewOrderMultilegLegsLegAllocsGroupElem
makeNewOrderMultilegLegsLegAllocsGroupElem newOrderMultilegLegsLegAllocsGroupElemLegAllocAccount =
  let newOrderMultilegLegsLegAllocsGroupElemLegIndividualAllocID = Nothing
      newOrderMultilegLegsLegAllocsGroupElemNewOrderMultilegLegsLegAllocsNestedParties2Group = []
      newOrderMultilegLegsLegAllocsGroupElemLegAllocQty = Nothing
      newOrderMultilegLegsLegAllocsGroupElemLegAllocAcctIDSource = Nothing
      newOrderMultilegLegsLegAllocsGroupElemLegSettlCurrency = Nothing
   in (NewOrderMultilegLegsLegAllocsGroupElem {..})
