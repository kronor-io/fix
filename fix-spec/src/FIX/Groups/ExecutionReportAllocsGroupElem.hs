{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

-- | This module has been GENERATED by fix-codegen.
-- Any manual edits will be undone the next time fix-codegen is run.
module FIX.Groups.ExecutionReportAllocsGroupElem where

import Data.List.NonEmpty (NonEmpty)
import Data.Proxy
import Data.Validity
import FIX.Components.Class
import FIX.Fields.AllocAccount
import FIX.Fields.AllocQty
import FIX.Fields.MsgType
import FIX.Fields.NoAllocs
import FIX.Fields.USIID
import FIX.Fields.USIID2
import FIX.Fields.USIPrefix
import FIX.Fields.USIPrefix2
import FIX.Fields.UTIID
import FIX.Fields.UTIID2
import FIX.Groups.Class
import FIX.Groups.ExecutionReportAllocsNestedPartiesGroupElem
import GHC.Generics (Generic)

-- | GroupSpec
--   { groupName = "ExecutionReportAllocs"
--   , groupNumberField = "NoAllocs"
--   , groupPieces =
--       [ MessagePieceField "AllocAccount" True
--       , MessagePieceField "AllocQty" False
--       , MessagePieceField "USIPrefix" False
--       , MessagePieceField "USIID" False
--       , MessagePieceField "USIPrefix2" False
--       , MessagePieceField "USIID2" False
--       , MessagePieceField "UTIID" False
--       , MessagePieceField "UTIID2" False
--       , MessagePieceGroup
--           GroupSpec
--             { groupName = "ExecutionReportAllocsNestedParties"
--             , groupNumberField = "NoNestedPartyIDs"
--             , groupPieces =
--                 [ MessagePieceField "NestedPartyID" True
--                 , MessagePieceField "NestedPartyIDSource" False
--                 , MessagePieceField "NestedPartyRole" False
--                 , MessagePieceField "NestedPartyRoleQualifier" False
--                 , MessagePieceGroup
--                     GroupSpec
--                       { groupName = "ExecutionReportAllocsNestedPartiesNestedPartySubIDs"
--                       , groupNumberField = "NoNestedPartySubIDs"
--                       , groupPieces =
--                           [ MessagePieceField "NestedPartySubID" True
--                           , MessagePieceField "NestedPartySubIDType" False
--                           ]
--                       }
--                     False
--                 ]
--             }
--           False
--       ]
--   }
data ExecutionReportAllocsGroupElem = ExecutionReportAllocsGroupElem
  { executionReportAllocsGroupElemAllocAccount :: !AllocAccount,
    executionReportAllocsGroupElemAllocQty :: !(Maybe AllocQty),
    executionReportAllocsGroupElemUSIPrefix :: !(Maybe USIPrefix),
    executionReportAllocsGroupElemUSIID :: !(Maybe USIID),
    executionReportAllocsGroupElemUSIPrefix2 :: !(Maybe USIPrefix2),
    executionReportAllocsGroupElemUSIID2 :: !(Maybe USIID2),
    executionReportAllocsGroupElemUTIID :: !(Maybe UTIID),
    executionReportAllocsGroupElemUTIID2 :: !(Maybe UTIID2),
    executionReportAllocsGroupElemExecutionReportAllocsNestedPartiesGroup :: ![ExecutionReportAllocsNestedPartiesGroupElem]
  }
  deriving stock (Show, Eq, Generic)

instance Validity ExecutionReportAllocsGroupElem

instance IsComponent ExecutionReportAllocsGroupElem where
  toComponentFields ((ExecutionReportAllocsGroupElem {..})) =
    mconcat
      [ requiredFieldB executionReportAllocsGroupElemAllocAccount,
        optionalFieldB executionReportAllocsGroupElemAllocQty,
        optionalFieldB executionReportAllocsGroupElemUSIPrefix,
        optionalFieldB executionReportAllocsGroupElemUSIID,
        optionalFieldB executionReportAllocsGroupElemUSIPrefix2,
        optionalFieldB executionReportAllocsGroupElemUSIID2,
        optionalFieldB executionReportAllocsGroupElemUTIID,
        optionalFieldB executionReportAllocsGroupElemUTIID2,
        optionalGroupB executionReportAllocsGroupElemExecutionReportAllocsNestedPartiesGroup
      ]
  fromComponentFields = do
    executionReportAllocsGroupElemAllocAccount <- requiredFieldP
    executionReportAllocsGroupElemAllocQty <- optionalFieldP
    executionReportAllocsGroupElemUSIPrefix <- optionalFieldP
    executionReportAllocsGroupElemUSIID <- optionalFieldP
    executionReportAllocsGroupElemUSIPrefix2 <- optionalFieldP
    executionReportAllocsGroupElemUSIID2 <- optionalFieldP
    executionReportAllocsGroupElemUTIID <- optionalFieldP
    executionReportAllocsGroupElemUTIID2 <- optionalFieldP
    executionReportAllocsGroupElemExecutionReportAllocsNestedPartiesGroup <- optionalGroupP
    pure (ExecutionReportAllocsGroupElem {..})

instance IsGroupElement ExecutionReportAllocsGroupElem where
  type GroupNumField ExecutionReportAllocsGroupElem = NoAllocs
  mkGroupNum Proxy = NoAllocs
  countGroupNum Proxy = unNoAllocs

makeExecutionReportAllocsGroupElem :: AllocAccount -> ExecutionReportAllocsGroupElem
makeExecutionReportAllocsGroupElem executionReportAllocsGroupElemAllocAccount =
  let executionReportAllocsGroupElemAllocQty = Nothing
      executionReportAllocsGroupElemUSIPrefix = Nothing
      executionReportAllocsGroupElemUSIID = Nothing
      executionReportAllocsGroupElemUSIPrefix2 = Nothing
      executionReportAllocsGroupElemUSIID2 = Nothing
      executionReportAllocsGroupElemUTIID = Nothing
      executionReportAllocsGroupElemUTIID2 = Nothing
      executionReportAllocsGroupElemExecutionReportAllocsNestedPartiesGroup = []
   in (ExecutionReportAllocsGroupElem {..})
