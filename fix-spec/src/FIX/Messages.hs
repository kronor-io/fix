{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}

-- | This module has been GENERATED by fix-codegen.
-- Any manual edits will be undone the next time fix-codegen is run.
module FIX.Messages
  ( AnyMessage (..),
    anyMessageType,
    anyMessageB,
    anyMessageP,
    IsAnyMessage (..),
    module X,
  )
where

import Data.ByteString (ByteString)
import qualified Data.ByteString.Builder as ByteString
import Data.Validity
import Data.Void (Void)
import FIX.Fields
import FIX.Messages.Class
import FIX.Messages.Envelope
import FIX.Messages.Heartbeat as X
import FIX.Messages.Logon as X
import FIX.Messages.Logout as X
import FIX.Messages.Quote as X
import FIX.Messages.QuoteRequest as X
import GHC.Generics (Generic)
import Text.Megaparsec

data AnyMessage
  = SomeHeartbeat !Heartbeat
  | SomeLogout !Logout
  | SomeLogon !Logon
  | SomeQuoteRequest !QuoteRequest
  | SomeQuote !Quote
  deriving stock (Show, Eq, Generic)

instance Validity AnyMessage

anyMessageType :: AnyMessage -> MsgType
anyMessageType = \case
  SomeHeartbeat _ -> MsgTypeHeartbeat
  SomeLogout _ -> MsgTypeLogout
  SomeLogon _ -> MsgTypeLogon
  SomeQuoteRequest _ -> MsgTypeQuoteRequest
  SomeQuote _ -> MsgTypeQuote

anyMessageB :: Envelope AnyMessage -> ByteString.Builder
anyMessageB ((Envelope {..})) =
  let mb ::
        forall a.
        (IsMessage a) =>
        a ->
        ByteString.Builder
      mb = messageB envelopeHeader envelopeTrailer
   in case envelopeContents of
        SomeHeartbeat f -> mb f
        SomeLogout f -> mb f
        SomeLogon f -> mb f
        SomeQuoteRequest f -> mb f
        SomeQuote f -> mb f

anyMessageP :: Parsec Void ByteString (Envelope AnyMessage)
anyMessageP = do
  SomeBeginString bs <- anyFieldP
  SomeBodyLength bl <- anyFieldP
  SomeMsgType typ <- anyFieldP
  let mp ::
        forall f.
        (IsMessage f) =>
        Parsec Void ByteString (Envelope f)
      mp = messageP bs bl typ
  case typ of
    MsgTypeHeartbeat -> fmap SomeHeartbeat <$> mp
    MsgTypeLogout -> fmap SomeLogout <$> mp
    MsgTypeLogon -> fmap SomeLogon <$> mp
    MsgTypeQuoteRequest -> fmap SomeQuoteRequest <$> mp
    MsgTypeQuote -> fmap SomeQuote <$> mp
    _ -> fail ("Unknown message tag: " <> show typ)

class (IsMessage a) => IsAnyMessage a where
  unpackAnyMessage :: AnyMessage -> Maybe a
  packAnyMessage :: a -> AnyMessage

instance IsAnyMessage Heartbeat where
  packAnyMessage = SomeHeartbeat
  unpackAnyMessage = \case
    SomeHeartbeat f -> Just f
    _ -> Nothing

instance IsAnyMessage Logout where
  packAnyMessage = SomeLogout
  unpackAnyMessage = \case
    SomeLogout f -> Just f
    _ -> Nothing

instance IsAnyMessage Logon where
  packAnyMessage = SomeLogon
  unpackAnyMessage = \case
    SomeLogon f -> Just f
    _ -> Nothing

instance IsAnyMessage QuoteRequest where
  packAnyMessage = SomeQuoteRequest
  unpackAnyMessage = \case
    SomeQuoteRequest f -> Just f
    _ -> Nothing

instance IsAnyMessage Quote where
  packAnyMessage = SomeQuote
  unpackAnyMessage = \case
    SomeQuote f -> Just f
    _ -> Nothing
