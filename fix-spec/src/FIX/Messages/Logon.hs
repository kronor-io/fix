{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

-- | This module has been GENERATED by fix-codegen.
-- Any manual edits will be undone the next time fix-codegen is run.
module FIX.Messages.Logon where

import Data.List.NonEmpty (NonEmpty)
import Data.Proxy
import Data.Validity
import FIX.Components.Class
import FIX.Fields.EncryptMethod
import FIX.Fields.HeartBtInt
import FIX.Fields.MsgType
import FIX.Fields.Password
import FIX.Fields.ResetSeqNumFlag
import FIX.Groups.Class
import FIX.Messages.Class
import GHC.Generics (Generic)

-- | MessageSpec
--   { messageName = "Logon"
--   , messageType = "A"
--   , messageCategory = "admin"
--   , messagePieces =
--       [ MessagePieceField "EncryptMethod" True
--       , MessagePieceField "HeartBtInt" True
--       , MessagePieceField "ResetSeqNumFlag" True
--       , MessagePieceField "Password" True
--       ]
--   }
data Logon = Logon
  { logonEncryptMethod :: !EncryptMethod,
    logonHeartBtInt :: !HeartBtInt,
    logonResetSeqNumFlag :: !ResetSeqNumFlag,
    logonPassword :: !Password
  }
  deriving stock (Show, Eq, Generic)

instance Validity Logon

instance IsComponent Logon where
  toComponentFields ((Logon {..})) =
    mconcat
      [ requiredFieldB logonEncryptMethod,
        requiredFieldB logonHeartBtInt,
        requiredFieldB logonResetSeqNumFlag,
        requiredFieldB logonPassword
      ]
  fromComponentFields = do
    logonEncryptMethod <- requiredFieldP
    logonHeartBtInt <- requiredFieldP
    logonResetSeqNumFlag <- requiredFieldP
    logonPassword <- requiredFieldP
    pure (Logon {..})

instance IsMessage Logon where
  messageType Proxy = MsgTypeLogon

makeLogon :: EncryptMethod -> (HeartBtInt -> (ResetSeqNumFlag -> (Password -> Logon)))
makeLogon logonEncryptMethod logonHeartBtInt logonResetSeqNumFlag logonPassword =
  let
   in (Logon {..})
